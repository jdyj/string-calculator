/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package string.calculator;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.List;
import java.util.Stack;
import org.junit.jupiter.api.Test;

/**
 * 의미있는 단위로 테스트 쪼개기
 * 테스트 메소드 이름, 설명 쓰기
 * run(String 타입)으로 받기
 * return 값 스트링 타입으로
 * main 메서드 테스트할 수 있도록 해보아라 (System.in)을 왜 써야할까 ? 를 기점으로 시작
 *
 * 충격적인 요구사항
 * 1
 * 연산자체는 + - * / ( ) 인데,
 * 큰 수 2^63 이상 표현할수 있도록 지원 제곱계산 넣기 2^2 = 4
 * 힌트 울프람알파 -> 답 검증
 *
 * 2
 * 값 형식 (단순 정수, 제곱, 기약분수형태)
 * 결과 포맷을 어떻게 받을건지
 * 과학적 표기방법으로 할건지 또는 단순 정수로 받을건지 할수있도록
 *
 * 3
 * 진법 지원
 * 입력, 출력 각각
 * 2진법 8진법 10진법 16진법
 * 입출력 할때 몇진법으로 할건지
 *
 * expression, 결과 포멧, 입출력 진법
 *
 * 이 외에 할 것들
 * 로마자(입출력 계산 가능해야함),
 * 병렬계산 (병렬지수 입력하게),
 * 걸린시간 (계산시간) (전체 걸린 시간 몇초다) (각각 부분에 대해서 걸린 시간이 몇초인지),
 * 포맷 형식 체크(이상한 입력 들어오면 알려주는것 1++2 --> 3번째 입력이 잘못되었다. 힌트느낌 sql syntax 에러느낌),
 * 출력 포맷 지정(json, xml, plain-text) { result: 10, 진법: 16 } xml, plain-text 도 가능하도록,
 * 출력 위치 지정(stdout, local file system (파일 입출력), web(웹서버 띄워서 띄우기)),
 * custom 기호 (3$$2 --> (3*2)^2) 지정할수 있도록,
 * 부동소수점 정확도 1. (정확도가 반드시 정확해야함.(분수를 사용해서 정확하도록)) 2. (유효숫자 5자리까지),
 * 분수 형태 지원 5/3, 6/7 지원 받도록, 출력 분수형태로도 가능하도록,
 * 복소수 계산 지원 (3i + 7) * -9i,
 * 미분 연산자 지원,
 * 계산 과정 시각화(분수 표현 지원),
 * 루트,
 * 삼각함수,
 * 설정 기억 기능(사용자 인식, 입력 옵션 기억)
 * 최대 계산 시간 (예 : 10초안에 계산을 못하면 취소. 10초이상 걸려서 계산 불가, a+b 7초 + 8초, 병렬 계산으로 한다면 성공할거 같다.)
 */
class AppTest {

  @Test
  void addTest() {
    assertEquals(App.add(1, 2), 3);
  }

  @Test
  void runTest() {
    String input = "1+2-3+4+5-6-7";
    List<Character> chars = input.chars().mapToObj(c -> (char) c).toList();

    assertEquals(App.run(chars), -4);

    input = "1+2-3*4+5-6*7";
    chars = input.chars().mapToObj(c -> (char) c).toList();

    assertEquals(App.run(chars), -46);

    input = "1+3/3*4+5-6*7";
    chars = input.chars().mapToObj(c -> (char) c).toList();

    assertEquals(App.run(chars), -32);

    input = "5 * (1+3/3*4+(5-6)*7) - 5";
    chars = input.chars().mapToObj(c -> (char) c).toList();

    assertEquals(App.run(chars), -15);

    input = "(1/0)";
    chars = input.chars().mapToObj(c -> (char) c).toList();

    List<Character> finalChars = chars;
    assertThrows(IllegalStateException.class, () ->
        App.run(finalChars)
    );

    input = "(((1)))";
    chars = input.chars().mapToObj(c -> (char) c).toList();

    assertEquals(App.run(chars), 1);
  }

  // 굳이 안해도됨 따로 클래스 만들어서 로직을 쪼개서 테스트하라
  @Test
  void calculateTest() {

    Stack<Character> operatorStack = new Stack<>();
    Stack<Double> numberStack = new Stack<>();

    operatorStack.push('+');

    numberStack.push(10.0);
    numberStack.push(20.0);

    assertEquals(App.calculate(operatorStack, numberStack), 30);
  }

  @Test
  void reverseStackTest() {
    Stack<Double> numberStack = new Stack<>();
    numberStack.push(1.0);
    numberStack.push(2.0);

    App.reverseStack(numberStack);

    assertEquals(numberStack.peek(), 1);

  }

  // 별도의 인터페이스나 클래스로 뽑아보기
  @Test
  void operatorSelectTest() {

    Stack<Double> numberStack = new Stack<>();

    // 덧셈
    double leftValue = 10;
    double rightValue = 20;
    char operator = '+';

    App.operatorSelect(numberStack, leftValue, rightValue, operator);

    Double result1 = numberStack.pop();
    assertEquals(result1, 30);

    // 뺄셈
    leftValue = 10;
    rightValue = 20;
    operator = '-';

    App.operatorSelect(numberStack, leftValue, rightValue, operator);
    Double result2 = numberStack.pop();
    assertEquals(result2, -10);

    // 곱셈
    leftValue = 10;
    rightValue = 20;
    operator = '*';

    App.operatorSelect(numberStack, leftValue, rightValue, operator);
    Double result3 = numberStack.pop();
    assertEquals(result3, 200);

  }

  @Test
  void calculateOneTest() {

    Stack<Double> numberStack = new Stack<>();
    Stack<Character> operatorStack = new Stack<>();

    numberStack.push(5.0);
    numberStack.push(7.0);

    operatorStack.push('*');

    App.calculateOne(operatorStack, numberStack);

    Double result = numberStack.pop();

    assertEquals(result, 35);

  }

  @Test
  void stackAddTest() {

    StringBuilder sb = new StringBuilder();
    sb.append(1);
    sb.append(3);

    Stack<Character> operatorStack = new Stack<>();
    Stack<Double> numberStack = new Stack<>();

    numberStack.push(30.0);
    numberStack.push(2.0);
    operatorStack.push('+');
    operatorStack.push('*');

    App.stackAdd(sb, operatorStack, numberStack, '-');

    Double result = numberStack.peek();
    assertEquals(result, 26);
  }

}
